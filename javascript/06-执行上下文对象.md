# 执行上下文环境对象和执行上下文环境栈
***

* 执行上下文环境对象和执行上下文环境栈
	* 上下文: 由js引擎自动创建的对象, 包含对应作用域中的变量属性
	* 变量提升: 在变量定义语句之前, 就可以访问到这个变量
	* 分类:
		* 全局 : window
		* 函数
	* 生命周期
		* 全局 : 准备执行全局代码前产生, 当页面刷新/关闭页面时死亡
		* 函数 : 调用函数时产生, 函数执行完时死亡
	* 包含哪些属性:
		* 全局: 
			* 用var定义的全局变量 --> undefined
			* 使用function声明的函数 --> function
			* this --> window
		* 函数
			* 用var定义的局部变量 --> undefined
			* 使用function声明的函数 --> function
			* this --> 调用函数的对象, 如果没有指定就是window 
			* 形参变量 --> 对应实参值
			* arguments --> 实参列表的伪数组
	* 上下文对象创建和初始化的过程
		* 全局:
			* 在全局代码执行前最先创建一个全局上下文对象(window)
			* 收集一些全局变量, 并初始化
			* 将这些变量设置为上下文对象的属性
		* 函数:
			* 在调用函数时, 在执行函数体之前先创建一个函数上下文对象
			* 收集一些局部变量, 并初始化
			* 将这些变量设置为上下文对象的属性
* 浏览器执行代码的流程：
  * 开辟一块内存作为执行环境
  * 创建一个"变量对象"用来保存程序执行过程当中的所有的变量
    * 变量对象是不可访问的, 但是除了全局执行环境的变量对象
    * 全局执行环境的变量对象是window对象
    * 程序运行过程中所有的变量都会作为变量的对象属性保存, 
      而所有的函数都会作为变量对象的方法保存
    * 我们在全局执行环境中的所有的变量, 和函数都会设置为window对象的属性和方法	
  * 预解析
    * 这时代码并不会由上至下执行, 而是找两个东西var和function(函数声明表达式)
    * 所有的var都会被设置为变量对象的属性, 但是并不会赋值, 也就是是undefined
    * 所有的函数声明表达式中的函数, 都会设置为变量对象的方法并赋值完毕
      (函数声明表达式是在第三步执行的, 第四步已经不会在执行了)
    * 没写var声明的变量, 都会在第四步进行赋值, 所有的没写var的变量最终都会作为window对象的属性保存, 
      也就是会变成全局变量
  * 逐行执行代码
    * 一行一行的执行程序的代码, 但是函数声明表达式不会再执行
  * 代码执行完毕
    * 销毁执行环境（腾出内存的空间）
    * 注意：全局执行环境不会在代码执行完毕后立即销毁,
      它会在浏览器关闭以后才销毁
* 函数执行环境
  * 函数执行环境和全局执行环境步骤是一样的, 只不过它范围要小一些


