# 运算符
## 目录
* [算数运算符](#算数运算符)
* [自增、自减](#自增、自减)
* [逻辑操作符](#逻辑操作符)
* [赋值运算符](#赋值运算符)
* [关系运算符](#关系运算符)
* [相等、不等、全等、全不等](#相等、不等、全等、全不等)
* [条件运算符](#条件运算符)
* [运算符的优先级](#运算符的优先级)
* [隐式的类型的类型转换](#隐式的类型的类型转换)
* [typeof运算符](#typeof运算符)
***

## 算数运算符
* 算数运算符：![](/images/算数运算符.png)
  * 将其他基础类型转换为Number, 前面加 "+"即可
  * 例:
```
  var str = 'abc'; // String
  str = + str; // Number
```
## 自增、自减
* 自增
  * 在原有值的基础上自增1
  * 分类：
    * a++
    * ++a
* 自减
  * 在原有值基础上自减1
  * 分类：
    * a--
    * --a
* 区别：
  * 无论是a++或++a, 调用以后, 原来的值都会自增1。只不过，a++是原变量a的值;++a是变量自增以后的值
  * 例：
```
  // a++
  var  a = 1;
  a++; // 1
  console.log(a); // 2
  // ++a
  var a = 1;
  ++a; // 2
  console.log(a); // 2
```
## 逻辑操作符
* `!`(逻辑非)
  * 使用!, 可以对一个值进行取反操作
  * 如果对一个非布尔值进行非运算, 则会先将其转换为布尔类型, 再取反, 返回布尔值
  * 例：
```
  var str = 'abc'; // String
  str = !!str; // Boolean
```
* `&&`(逻辑与)
  * 对"&&"符号两侧的值进行与运算
  * js中的与运算是短路的与, 一旦第一个值为false, 则不会去看第二个值, 直接返回false
    * 如果两个值为false, 则返回第一个false
    * 如果两个值为true, 则返回第二个true
  * 对非布尔值进行运算时, 它会将非布尔值转换为布尔值, 但是它会返回原值
* `||`(逻辑或)
  * 对"||"符号两侧的值进行或运算
  * js中的货运算是短路的或, 如果第一个值为true, 则不会去看第二个值, 直接返回true
    * 如果两个值都为false, 则返回第二个false
    * 如果两个值都为true, 则返回第第一个true
  * 对非布尔值进行运算时, 它会将非布尔值转换为布尔值, 但是它会返回原值
## 赋值运算符
* `=`(赋值操作符)
* 赋值运算符可以将符号右侧的值赋值给左侧变量
  * `+=`
  * `-=`
  * `*=`
  * `/=`
  * 例：
```
  var a = 123;
  a += 5; // a = a + 5;
  console.log(a); // 128
```
## 关系运算符
* 使用关系运算符可以比较两个变量之间的大小
  * `>` : 判断一个值是否大于另一个值
  * `>=` : 判断一个值是否大于等于另一个值
  * `<` : 判断一个值是否小于另一个值
  * `<=` : 判断一个值是否小于等于另一个值
* 如果是非数字的值进行比较时, 它会将他们转换为数字然后在比较
* 如果是两个字符串进行比较, 不会转换为数字, 而是比较它们的字符编码, 所以尽量不要比较两个字符串的大小
## 相等、不等、全等、全不等
* `==`(相等)
  * 判断符号两侧值是否相等, 如果相等则返回true, 否则返回false
  * 相等会对两侧值进行类型转换, 如果转换后相等, 它也会返回true
  * ==速查表：          
  ![](/images/==速查表.png)
* `!=`(不等)
  * 判断符号两侧值是否不等, 如果不等则返回true, 否则返回false
  * 不等会对两侧值进行类型转换, 如果转换后不等, 则也会返回true
* `===`(全等)
  * 判断符号两侧值是否全等, 和相等类似, 只不过全等不会自动转换数据类型
  * 如果比较的两个值类型不同, 则直接返回false
* `!==`(全不等)
  * 判断符号两侧值是否全部等, 和不等类似, 只不过全部等不会自动转换数据类型
  * 如果比较的两个值类型不同, 则直接返回false
* 注意：
  * 首先把javascript中的数据类型分成两组：
  		*	String、Number、Boolean和Object
  		*	Undefined和Null
  		*	1与2之间的比较都为false 
  		*	Undefined和Null之间的比较为true
  		* NaN 不等于 NaN
  		* undefined衍生自null, 所以`undefined == null; // true`;`undefined === null; // false`
      * NaN不与任何值相等, 包括它本身, 所以`NaN == NaN; // false`, 可以通过isNaN()来判断一个值是否为NaN
## 条件运算符
* 又名三目运算符, 三元运算符
* 语法：表达式1 ? 表达式2 : 表达式三
* 先执行表达式1, 如果表达式1为true, 则执行表达式2;如果表达式1为false, 则执行表达式3
## 运算符的优先级
* 优先级高的先运算, 低的后运算
* 运算符的优先级：![](/images/运算符的优先级.png)
* 表中内容
  * 越靠上优先级越高, 优先级越高越优先执行
  * 优先级相同的按照从左至右顺序执行
  * 如果想提升内容的优先级可以使用"()", 来提升小括号内内容的优先级
## 隐式的类型的类型转换
* 其他类型转换为String
  * 变量 = 变量+"";
  * 任何数据和字符串进行加法运算, 都会转换为字符串, 然后做拼串操作
  * 底层也是使用的String()
* 其他类型转换为Number
  * 变量 = +变量;
  * 使用一元的加会使变量自动转型为Number类型
  * 底层也是使用的Number()
* 其他类型转换为Boolean
  * 变量 = !!变量;
  * 我们可以为一个变量做两次取反操作, 来使其变为Boolean
  * 底层也是使用的Boolean()
## typeof运算符
* typeof运算符可以用来去检查一个变量的数据类型
* 语法：typeof 变量
  * 如果是数字类型, 返回number
  * 如果是字符串, 返回string
  * 如果是布尔值, 返回boolean
  * 如果是undefined, 则返回undefined
  * 其他返回 object
  * typeof运算符返回的结果的类型都是string
## 深入解析"=="
* parseInt(value)
* parseFloat(value)
  * 转换情况
    * 字符串->只要最高位是数字则会转换成数值;否则转换成NaN
    * 其它->NaN
* Number()
  * 转换情况
    * 就是把字符串两边的空白字符去掉, 然后把两边的引号去掉, 看它能否组成一个合法的数字  
    * 如果是, 转化结果就是这个数字, 否则, 结果是NaN
    * 当然也有例外, 比如空白字符串转化为数字的结果是0	
* undefined == null, 结果是true。且它俩与所有其他值比较的结果都是false。
* String == Boolean, 需要两个操作数同时转为Number
* String/Boolean == Number, 需要String/Boolean转为Number
* Object == Primitive, 需要Object转为Primitive(具体通过valueOf和toString方法)
* toString()
	* 当对象需要转换为字符串时, 会调用它的toString()方法
	* 默认情况下, 每个对象都会从Object上继承到toString()方法,  
	如果这个方法没有被这个对象自身或者更接近的上层原型上的同名方法覆盖(遮蔽), 
	则调用该对象的toString()方法时会返回"[object type]", 这里的字符串type表示了一个对象类型
* valueOf()	
	* JavaScript调用valueOf()方法用来把对象转换成原始类型的值(数值、字符串和布尔值) 
	* 很少需要自己调用此函数, JavaScript 会自动调用此函数当需要转换成一个原始值时
	* 默认情况下, valueOf()会被每个对象Object继承
	* 每一个内置对象都会覆盖这个方法为了返回一个合理的值
	* 如果对象没有原始值, valueOf()就会返回对象自己


















