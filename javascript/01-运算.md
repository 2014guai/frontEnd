# 运算符
## 目录
* [算数运算符](#算数运算符)
* [自增、自减](#自增、自减)
* [逻辑操作符](#逻辑操作符)
* [赋值运算符](#赋值运算符)
* [关系运算符](#关系运算符)
* [相等、不等、全等、全不等](#相等、不等、全等、全不等)
* [条件运算符](#条件运算符)
* [运算符的优先级](#运算符的优先级)
* [隐式的类型的类型转换](#隐式的类型的类型转换)
* [typeof运算符](#typeof运算符)
***

## 算数运算符
* 算数运算符：![](/images/算数运算符.png)
  * 将其他基础类型转换为Number，前面加 "+"即可
  * 例:
```
  var str = 'abc'; // String
  str = + str; // Number
```
## 自增、自减
* 自增
  * 在原有值的基础上自增1
  * 分类：
    * a++
    * ++a
* 自减
  * 在原有值基础上自减1
  * 分类：
    * a--
    * --a
* 区别：
  * 无论是a++或++a, 调用以后，原来的值都会自增1。只不过，a++是原变量a的值；++a是变量自增以后的值。
  * 例：
```
  // a++
  var  a = 1;
  a++; // 1
  console.log(a); // 2
  // ++a
  var a = 1;
  ++a; // 2
  console.log(a); // 2
```
## 逻辑操作符
* `!`(逻辑非)
  * 使用!,可以对一个值进行取反操作
  * 如果对一个非布尔值进行非运算，则会先将其转换为布尔类型，再取反，返回布尔值
  * 例：
```
  var str = 'abc'; // String
  str = !!str; // Boolean
```
* `&&`(逻辑与)
  * 对"&&"符号两侧的值进行与运算
  * js中的与运算是短路的与，一旦第一个值为false，则不会去看第二个值，直接返回false
    * 如果两个值为false，则返回第一个false
    * 如果两个值为true，则返回第二个true
  * 对非布尔值进行运算时，它会将非布尔值转换为布尔值，但是它会返回原值
* `||`(逻辑或)
  * 对"||"符号两侧的值进行或运算
  * js中的货运算是短路的或，如果第一个值为true，则不会去看第二个值，直接返回true
    * 如果两个值都为false，则返回第二个false
    * 如果两个值都为true，则返回第第一个true
  * 对非布尔值进行运算时，它会将非布尔值转换为布尔值，但是它会返回原值
## 赋值运算符
* `=`(赋值操作符)
* 赋值运算符可以将符号右侧的值赋值给左侧变量
  * `+=`
  * `-=`
  * `*=`
  * `/=`
  * 例：
```
  var a = 123;
  a += 5; // a = a + 5;
  console.log(a); // 128
```
## 关系运算符
* 使用关系运算符可以比较两个变量之间的大小
  * `>` : 判断一个值是否大于另一个值
  * `>=` : 判断一个值是否大于等于另一个值
  * `<` : 判断一个值是否小于另一个值
  * `<=` : 判断一个值是否小于等于另一个值
* 如果是非数字的值进行比较时，它会将他们转换为数字然后在比较
* 如果是两个字符串进行比较，不会转换为数字，而是比较它们的字符编码，所以尽量不要比较两个字符串的大小
## 相等、不等、全等、全不等
* `==`(相等)
  * 判断符号两侧值是否相等，如果相等则返回true，否则返回false
  * 相等会对两侧值进行类型转换，如果转换后相等，它也会返回true
  * ==速查表：          
  ![](/images/==速查表.png)
* `!=`(不等)
  * 判断符号两侧值是否不等，如果不等则返回true，否则返回false
  * 不等会对两侧值进行类型转换，如果转换后不等，则也会返回true
* `===`(全等)
  * 判断符号两侧值是否全等，和相等类似，只不过全等不会自动转换数据类型
  * 如果比较的两个值类型不同，则直接返回false
* `!==`(全不等)
  * 判断符号两侧值是否全部等，和不等类似，只不过全部等不会自动转换数据类型
  * 如果比较的两个值类型不同，则直接返回false
* 注意：
  * 首先把javascript中的数据类型分成两组：
  		*	String、Number、Boolean和Object
  		*	Undefined和Null
  		*	1与2之间的比较都为false 
  		*	Undefined和Null之间的比较为true
  		* NaN 不等于 NaN
  		* undefined衍生自null，所以`undefined == null; // true`;`undefined === null; // false`
      * NaN不与任何值相等，包括它本身，所以`NaN == NaN; // false`,可以通过isNaN()来判断一个值是否为NaN
## 条件运算符
* 又名三目运算符，三元运算符
* 语法：表达式1 ? 表达式2 : 表达式三
* 先执行表达式1，如果表达式1为true，则执行表达式2；如果表达式1为false，则执行表达式3
## 运算符的优先级
* 优先级高的先运算，低的后运算
* 运算符的优先级：![](/images/运算符的优先级.png)
* 表中内容
  * 越靠上优先级越高，优先级越高越优先执行
  * 优先级相同的按照从左至右顺序执行
  * 如果想提升内容的优先级可以使用"()"，来提升小括号内内容的优先级
## 隐式的类型的类型转换
* 其他类型转换为String
  * 变量 = 变量+"";
  * 任何数据和字符串进行加法运算，都会转换为字符串，然后做拼串操作
  * 底层也是使用的String()
* 其他类型转换为Number
  * 变量 = +变量;
  * 使用一元的加会使变量自动转型为Number类型
  * 底层也是使用的Number()
* 其他类型转换为Boolean
  * 变量 = !!变量;
  * 我们可以为一个变量做两次取反操作，来使其变为Boolean
  * 底层也是使用的Boolean()
## typeof运算符
* typeof运算符可以用来去检查一个变量的数据类型
* 语法：typeof 变量
  * 如果是数字类型，返回number
  * 如果是字符串，返回string
  * 如果是布尔值，返回boolean
  * 如果是undefined，则返回undefined
  * 其他返回 object
  * typeof运算符返回的结果的类型都是string



















