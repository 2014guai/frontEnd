# 函数
## 概述
* 函数也是对象
* 除了可以封装属性外, 还可以封装可执行的代码
* 函数调用时, 内部代码才会执行
## 目录
[函数的创建](#函数的创建)
[IIFE](#IIFE)
***

## 函数的创建
* 构造函数
  * `var obj = new Object()`
  * 其实构造函数就是一个普通的一个函数，但是我们的构造函数习惯首字母大写
  * 构造函数通过new关键字来调用
  * 定义一个构造函数：
    * ```
        function CreatPerson(name , age){
          this.name = name;
          this.age = age;
          this.sayHello = function(){};
        }
         var jc = new CreatPerson();
      ```
  * 构造函数的执行的过程：
    * 创建一个新的对象
    * 以这个新对象作为this，然后调用函数
    * 将新建的对象作为返回值返回
  * 每一个对象都有一个隐含的属性constructor，用来保存它自己的构造函数。
  * 可以通过instanceof来判断一个对象是否属于某个构造函数的实例
  * 语法：对象 instanceof 构造函数，如果是则返回true，否则返回false
    由于Object是所有对象的祖先，所以任何对象和Object进行instanceof运算都会返回true
* 函数声明表达式
  * ```
    function fn (){
      语句...
    }
    ```
* 匿名函数
  * ``` 
    var fn = function(){
      语句..
    }
    ```
* 工厂方法
    * 例:
      * ```
          // 工厂函数
          function createPerson(name , age){
            //新创建一个对象
            var obj = new Object();
            //向对象中添加属性和方法
            obj.name = name;
            obj.age = age;
            obj.sayHello = function(){};
            
            //将对象返回
            return obj;
          }
          // 创建实例
          var per = createPerson("swk",18);
        ```
      * 使用工厂方法创建的对象全都是Object类型的对象，我们无法识别不同的对象的类型
      * 我们希望创建一个人的对象，使用Person() 创建一个狗的对象，使用Dog()
## this && arguments
* this
  * 浏览器在调用一个函数时，它会默认传递进一个参数，这个参数叫this，代表的是执行函数的上下文对象。
  * this在不同的情况下代表不同的对象：
    * 当函数作为一个方法调用时，谁调用的函数this就是谁。
      例子：obj.fun() --> this就是obj
    * 当作为一个函数调用时，this永远都是window
      例子：fun() ---> this就是window （window.fun()）
    * 当作为一个构造函数调用时，this就是新创建的那个对象
      例子：var per = new Person() --> this --> per
* arguments
  * 每个函数在执行时，浏览器都会默认传递两个隐藏的参数
    * 一个是执行的上下文对象：this
    * 一个是封装实参的对象：arguments
  * arguments是类数组的对象，我们调用函数时所有的实参都会在arguments中保存。
    * 我们可以通过arguments[索引]来获取实参。
  * arguments中还封装了一个属性callee，这个属性指向的是当前函数本身。
## 改变this
* call() && apply() 
  * 这两个方法作用类似，都是需要通过函数对象来调用，当一个函数对象调用这两个方法，
    函数就会立即被调用，他们和普通的函数调用的区别是，这两个方法可以指定this对象。
  * 用法：
    * 函数对象.call(this对象,实参1,实参2,实参N)
    * 函数对象.apply(this对象,[实参的数组])
  * this到底是谁？
    * 以函数形式调用时，this永远是window
    * 以方法的形式调用时，this就是调用方法的那个对象
    * 以构造函数调用时，this就是新创建的对象
    * 使用call和apply调用时，this就是指定的那个对象
##IIFE
* 为什么会有IIFE
  * 在javascript中，每一个函数在被调用的时候都会创建一个执行上下文，
  * 在该函数内部定义的变量和函数只能在该函数内部被使用，
  * 而正是因为这个上下文，使得我们在调用函数的时候能创建一些私有变量。
* 执行的过程
  * 因为在javascript里，括号内部不能包含语句，当解析器对代码进行解释的时候，先碰到了()，
  * 然后碰到function关键字就会自动将()里面的代码识别为函数表达式而不是函数声明。
* 两种常见写法
  * (function(){}())
  * (function(){})()
* 优点
  * 提升性能
    * 减少作用域的查找
    * 参数一般为window、document、jQuery
    * 将全局对象放在IIFE作用域内提升JS解析器的查找速度和性能
  * 有利于压缩
  * 避免冲突
  * 依赖加载
* 应用
  * jQuery
## 执行环境
* JS引擎（浏览器）在运行JS代码的时候，需要准备一个环境用来执行JS代码，这个环境就是我们说的执行环境。
* 执行环境分成两种：全局执行环境和函数执行环境
* 浏览器执行代码的流程：
  * 开辟一块内存作为执行环境
  * 创建一个“变量对象”用来保存程序执行过程当中的所有的变量
    * 变量对象是不可访问的，但是除了全局执行环境的变量对象
    * 全局执行环境的变量对象是window对象
    * 程序运行过程中所有的变量都会作为变量的对象属性保存
      而所有的函数都会作为变量对象的方法保存
    * 我们在全局执行环境中的所有的变量，和函数都会设置为window对象的属性和方法。	
  * 预解析
    * 这时代码并不会由上至下执行，而是找两个东西var和function（函数声明表达式）
    * 所有的var都会被设置为变量对象的属性，但是并不会赋值，也就是是undefined
    * 所有的函数声明表达式中的函数，都会设置为变量对象的方法并赋值完毕
    （函数声明表达式是在第三步执行的，第四步已经不会在执行了）
    * 没写var声明的变量，都会在第四步进行赋值，所有的没写var的变量最终都会作为window对象的属性保存
      也就是会变成全局变量！！
  * 逐行执行代码
    * 一行一行的执行程序的代码，但是函数声明表达式不会再执行。
    
  * 代码执行完毕
    * 销毁执行环境（腾出内存的空间）
    * 注意：全局执行环境不会在代码执行完毕后立即销毁
        它会在浏览器关闭以后才销毁。
* 函数执行环境
  * 函数执行环境和全局执行环境步骤是一样的，只不过它范围要小一些
  
* 作用域：
  * 作用域指的是我们在某个执行环境只能访问作用域以内的变量，而超出这个作用域的变量，我们将不能访问。
## 作用域
* 作用域链
	* 当执行一个函数时，在函数中使用变量时，它会现在自身的作用域中查找变量
		如果自身没有，则向上一级的函数作用域寻找，如果还没有则继续寻找,
		如果所有的上级的函数作用域中都没有，则向全局作用域中寻找，全局作用域在没有则报错。
	* 我们这些函数作用域和全局作用域就构成一条作用域的链。
	* 闭包：
		* 内部的函数可以访问到外部函数声明的变量，但是外部函数不能访问内部函数中的变量，这就形成了一个闭包。
		* 特点：
			当外部函数执行完毕以后，使用内部函数依然可以访问到外部函数中的变量。
## 原型（prototype）
* 每一个函数在创建完成之后，都会默认添加一个prototype属性，
  这个属性指向的是一个对象，这个对象就是我们所说的原型对象。
* 当函数作为构造函数使用时，每次使用该函数创建的对象中，
  都会有一个隐含的属性去指向prototype属性对应的对象。	
    也就是说所有的通过相同的构造函数创建的对象，都有一个共同的原型对象。
* 当我们去调用一个对象的方法或读取属性时，它会先去对象自身中寻找，
  如果自身中没有，则向原型中寻找，如果原型中也没有，则上原型的原型中寻找，
    以此类推，当找到Object对象的原型时，便不再寻找，因为Object对象的原型没有原型。
* Object对象的原型没有原型对象，它是我们所有的对象的祖先。
* 当前对象的原型，原型的原型，等等等这一系列的原型对象就构成我们当前对象的原型链，
  当从对象中读取属性或调用方法时，会沿着原型链查找，如果找到则返回并停止查找，如果没找到则返回undefined。
* 一般情况下同一个类型的对象他们的原型对象只有一个，
  所以我们可以将一类对象中共有的属性和方法统一设置到原型对象中
    这样所有的该类的实例都可以访问这些属性并使用这些方法。
* 例子：
```
  function Person(name , age){
    this.name = name;
    this.age = age;
  }
  
  Person.prototype.sayHello = function(){};
```  
* 原型的设置：
  * 语法：
    * 读取原型：
      * 构造函数.prototype
      * 对象.__proto__  //这个不是所有的浏览器都支持的，它也不是ES标准中定义的内容。
    * 向原型对象中添加属性或方法
      * 构造函数.prototype.属性名 = 属性值
      * 构造函数.prototype.方法名 = function(){}
    * 直接修改原型对象
      * 构造函数.prototype = 新的对象
      
      
      
###函数

* 每个构造函数都拥有一个原型对象，原型对象都包含一个指向构造函数的指针（constructor），实例都包含一个指向原型对象的内部指针（_proto_）。

* 函数
  * 多条可执行语句的封装体---->函数是一个可执行的东西
  * 函数也是对象
    * 从语法上判断 : instanceof
    * 可以通过.操作内部属性/方法: fn.prototype/fn.call()/apply()
  * 函数的3种不同角色
    * 一般函数 : 直接调用
    * 构造函数 : 通过new调用
    * 对象 : 通过.调用内部的属性/方法
  * 函数中的this
    * 显式指定谁: obj.xxx()
    * 通过call/apply指定谁调用: xxx.call(obj)                                                    
    * 不指定谁调用: xxx()  : window
    * 回调函数: 看背后是通过谁来调用的: window/其它
  *-this：
        - this的指向：
            - 全局环境：this始终指向的是window对象
            - 局部环境：
                - 直接调用函数：this指向 window
                - 对象函数调用：哪个对象调用就指向哪个对象
                - 使用 new 实例化对象，在构造函数中的this指向实例化对象。
            - 使用call或apply、bind()改变this的指向
                - apply 、 call 、bind 三者都是用来改变函数的this对象的指向的；
                - apply 、 call 、bind 三者第一个参数都是this要指向的对象，也就是想指定的上下文；
                - apply 、 call 、bind 三者都可以利用后续参数传参；
                - bind 是返回对应函数，便于稍后调用；apply 、call 则是立即调用 。
        - 使用场景：
            - 用于区分全局变量和局部变量，需要使用this
            - 返回函数当前的对象： 比如jQuery源码
            - 将当前的对象传递到下一个函数： 好吧--->还是jQuery， 
  * 函数自调用:
    (function(window, obj){
      //函数体
    })(window, obj)