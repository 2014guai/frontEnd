JS中的继承主要依靠原型链。

 

1.每个构造函数都拥有一个原型对象，原型对象都包含一个指向构造函数的指针（constructor），实例都包含一个指向原型对象的内部指针（_proto_）。

	如果对原型进行多次赋值，那么后面的赋值会覆盖前面的，也就是通过原型链只能继承离实例化最近的一个 原型对象。
	
	原型链继承的本质就是一个单链表的深度搜索。例如，原型对象（Son.prototype）等于另一个原型（Person）的实例（person1），那么此时的原型对象（Son.prototype）将包含一个指向另一个原型（Person.prototype）的指针，相应的，另有一个原型（Person.prototype）中也包含着一个指向另一个构造函数（Person()）的指针。
	
	再如，另一个原型（Person.prototype）又是另一个类型（Person）的实例（person1）,那么上述关系依旧成立，如此层层递进，就构成了实例与原型的链条。这就是所谓的原型链。
	
	所有引用类型默认继承了Object类型，所有函数的默认原型都是Object的实例，因此默认原型都会包含一个内部指针，指向Object.prototype.这也正是自定义类型能通过使用toString()等默认方法的原因。
	
	在通过原型链实现继承时，不能使用对象字面量创建原型对象，这样会重写原型链。

 

 

2.call函数的用法（可用于实现继承）

	call([thisObj[,arg1[, arg2[,   [,.argN]]]]])，调用一个对象的一个方法，以另一个对象替换当前对象。
	
	call方法可以用来代替另一个对象调用一个方法。call方法可将一个函数的对象上下文从初始的上下文改变为由thisObj指定的新对象。如果没有提供thisObj参数，那么Global对象被用作thisObj。
	
	function Animal(name){ 
	  this.name = name; 
	  this.showName = function(){ 
	    alert(this.name); 
	  } 
	}
	
	function Cat(name){ 
	  Animal.call(this, name); 
	}
	
	var cat = new Cat("Black Cat"); 
	cat.showName();
	
	Animal.call(this) 的意思就是使用 Animal对象代替this对象，那么 Cat中不就有Animal的所有属性和方法了吗，Cat对象就能够直接调用Animal的方法以及属性了.
	
	同样，如果使用多个call就可以实现多重继承。