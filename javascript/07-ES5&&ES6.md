
#  对ES6最新规范有实际运用，熟悉箭头函数、解构、promise等新概念


* ES
	* ECMAScript
	* js语言的规范
	* 用的js是它的实现
	* js的组成
		* ECMAScript(js基础)
		* 浏览器端扩展
			* BOM
			* DOM
		* 服务器端扩展
			* Node.js
* ES5
	* 严格模式
		1. 理解:
			除了正常(混杂)运行模式，ECMAscript 5添加了第二种运行模式："严格模式"（strict mode）。
		    顾名思义，这种模式使得Javascript在更严格的条件下运行
		2. 目的/作用
			- 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;
			- 消除代码运行的一些不安全之处，保证代码运行的安全；
			- 提高编译器效率，增加运行速度；
			- 为未来新版本的Javascript做好铺垫。
		3. 使用
		    在全局或函数的第一条语句定义为: 'use strict';
		    如果浏览器不支持, 只解析为一条简单的语句, 没有任何副作用
		4. 限制语法
		    1. 声明定义变量必须用var
		    2. 创建eval作用域
		    3. 禁止函数中的this关键字指向全局对象
	* JSON对象
		1. 用于在json对象/数组与js对象/数组相互转换的工具对象
		2. JSON.stringify(obj/arr)
		    js对象(数组)转换为json对象(数组)
		3. JSON.parse(json)
		    json对象(数组)转换为js对象(数组)
	* Object扩展
		1. Object.create(prototype[, descriptors]) : 创建一个新的对象
		    1). 以指定对象为原型创建新的对象
		    2). 创建一个以null为对象原型，并添加一些属性描述
		2. Object.defineProperties(object, descriptors) : 为指定对象定义多个属性
			1). get/set属性
	* Array扩展
		1. Array.prototype.indexOf(value) : 得到值在数组中的第一个下标
		2. Array.prototype.lastIndexOf(value) : 得到值在数组中的最后一个下标
		3. Array.prototype.forEach(function(item, index){}) : 遍历数组
		4. Array.prototype.map(function(item, index){}) : 遍历数组返回一个新的数组
		5. Array.prototype.filter(function(item, index){}) : 遍历过滤出一个子数组
	* Function扩展
		Function.prototype.bind(obj) :
	    	将函数内的this绑定为obj, 并将函数返回
		区别
	    	fn.bind(obj) : 指定函数中的this, 并返回函数
	    	fn.call(obj) : 指定函数中的this,并调用函数
	* Date扩展
		* Date.now() : 得到当前时间值
* ES6
	* 2个新的关键字
		* let/const
		* 块作用域
		* 没有变量提升
		* 不能重复定义
		* 值不可变
	* 变量的解构赋值
		* 将多个数据一次赋值给多个变量
		* 数据源: 数组/对象
		* 目标: [a, b]/{a, b}
	* 各种数据类型的扩展
		* 数值
			 1. 二进制与八进制数值表示法: 二进制用0b, 八进制用0o
	         2. Number.isFinite(i) : 判断是否是有限大的数
	         3. Number.isNaN(i) : 判断是否是NaN
	         4. Number.isInteger(i) : 判断是否是整数
	         5. Number.parseInt(str) : 将字符串转换为对应的数值
	         6. Math.trunc(i) : 直接去除小数部分
		* 字符串
			 1. contains(str) : 判断是否包含指定的字符串
	         2. startsWith(str) : 判断是否以指定字符串开头
	         3. endsWith(str) : 判断是否以指定字符串结尾
	         4. repeat(count) : 重复指定次数
	         5. 模板字符串 : 简化字符串的拼接
	             1). 模板字符串必须用``饮食
	             2). 变化的部分使用${xxx}定义
		* 对象
			 1. Object.is(v1, v2) : 判断2个数据是否完全相等
	         2. Object.assign(target, source1, source2..) : 将源对象的属性复制到目标对象上
	         3. __proto__属性 : 隐式原型属性
	         4. 增强的对象写法
		* 数组
			 1. Array.from(v) : 将伪数组对象或可遍历对象转换为真数组
	         2. Array.of(v1, v2, v3) : 将一系列值转换成数组
	         3. find(function(value, index, arr){return true}) : 找出第一个满足条件返回true的元素
	         4. findIndex(function(value, index, arr){return true}) : 找出第一个满足条件返回true的元素下标
	         5. keys() : 返回包含所有下标的可迭代对象
	         6. values() : 返回包含所有值的可迭代对象
	         7. entries() : 返回包含所有下标和值的可迭代对象
		* 函数
			 1. 箭头函数
	         2. 形参的默认值
	         3. 可变参数
     * set/Map容器结构
		* 容器: 能保存多个数据的对象, 同时必须具备操作内部数据的方法
		* 任意对象都可以作为容器使用, 但有的对象不太适合作为容器使用(如函数)
		* Set的特点: 保存多个value, value是不重复 ====>数组元素去重
		* Map的特点: 保存多个key--value, key是不重复, value是可以重复的
		* API
			* Set()/Set(arr) //arr是一维数组
			* add(value)
			* delete(value)
			* clear();
			* has(value)
			* size
			* 
			* Map()/Map(arr) //arr是二维数组
			* set(key, value)
			* delete(key)
			* clear()
			* has(key)
			* size
	* for--of循环
		* 可以遍历任何容器
		* 数组
		* 对象
		* 伪/类对象
		* 字符串
		* 可迭代的对象
* 静态(工具)方法
	* Fun.xxx = function(){}
* 实例方法
	* 所有实例对象 : Fun.prototype.xxx = function(){} //xxx针对Fun的所有实例对象
	* 某个实例对象 : fun.xxx = function(){} //xxx只是针对fun对象

*test9(...args);
	...延展操作符
## ES6最新规范
1. 目标：
    - ECMAScript 是 JavaScript 语言的国际标准，JavaScript 是 ECMAScript 的实现。ES6 的目标，是使得 JavaScript 语言可以用来编写大型的复杂的应用程序，成为企业级开发语言。
    - 为什么没有ES4：
        - 曾经计划发布具有大量新特性的版4，但最终因想法太过激进而惨遭废除（这一版标准中曾经有一个极其复杂的支持泛型和类型推断的内建静态类型系统）
2. ECMAScript 发生了什么变化？
    - 语言语法 – 语法解析规则、关键字、语句、声明、运算符等。
    - 类型 – 布尔型、数字、字符串、对象等。
    - 原型和继承
    - 内建对象和函数的标准库 – JSON、Math、数组方法、对象自省方法等。
3. 版本5
    - 带来了严格模式
        - "use strict"
    - JSON
        - 提供一个全局的JSON对象，用来序列化(JSON.stringify)和反序列化(JSON.parse)对象为JSON格式。
    - 额外的数组(Array在ES5新增的方法中，参数都是function类型，默认有传参)
        - [1, 2 ,3, 4].forEach(alert);
            - forEach方法中的function回调支持3个参数，第1个是遍历的数组内容；第2个是对应的数组索引，第3个是数组本身。
        - array.map(callback,[ thisObject]);
            - callback 需要return
        - filter ： 过滤
            - array.filter(callback,[ thisObject]);
            - callback函数需要返回布尔值true或false
        - array.some(callback,[ thisObject]);
        - array.every(callback,[ thisObject]);
        -....
4. 版本6
    - 箭头操作符
    - 类的支持
        - 引入了class关键字（其实class在JavaScript中一直是保留字)
    - 增强的对象字面量
        - 可以在对象字面量里面定义原型
            -  __proto__: human, //设置此对象的原型为human,相当于继承human
        - 定义方法可以不用function关键字
        - 直接调用父类方法
    - 字符串模板
    - 解构 : [name,,age]=['wayou','male','secrect'];//数组解构
    - 参数默认值，不定参数，拓展参数
        - 默认参数值 function sayHello2(name='dude'){}
        - 不定参数:function add(...x){}
        - 拓展参数:
    - let与const 关键字
    - for of 值遍历
    - 模块
    - Map，Set
    - Promise 对象。
## 箭头函数
1. 语法作用域
    - 拥有词法作用域的this 
2. 语法：
    - ()=>{return 1;}
3. 特点：  
    - 箭头函数总是匿名的
    - 简洁语法
    - 与父作用域共享关键字this
    - 箭头函数与普通函数的再一个区别：不能使用arguments对象。
    - 箭头函数没有原型。
## 解构
1. 目的：按照一定规则，从对象或是数组中提取值。
2. 特点：
    - 解构赋值允许指定默认值
3. 使用： 
    - 数组：var [a,b,c] = [1,2,3]; //能嵌套
        - 如果解构不成功，变量的值就为undefined。
    - 对象形式的解构 var { foo, bar } = { foo: "aaa", bar: "bbb" };
    - 字符串的解构：const [a, b, c, d, e] = 'hello';
4. 用途：
    - 交换变量的值
    - 从函数返回多个值
    - 提取JSON数据
    - 输入模块的指定方法
4. 不完全解构
    - js是一种匹配不是一种严格匹配的语言，所以对于=两边的数组它们的形式即使不完全相同，也是能够赋值（当然前面的结果要是后面结构的子集）
## promise
0. 出现：
    - JS是单线程的，也就是一条线下来的，这是代码世界的一条规则。JS中发送一个异步的Ajax请求，不同的返回值造成不同的影响，大部分的操作结果都不是即时显现的，我们需要预先规划接下来的动作。
1. 就是Promise出现的意义：“将异步操作转换成更符合先知视角的形式展现”！
2. 所谓 Promise，就是一个对象，用来传递异步操作的消息。它代表了某个未来才会知道结果的事件（通常是一个异步操作），并且这个事件提供统一的 API，可供进一步处理。
3. Angular 同样使用$q 实现了promise
4. 特点：
    - Promise新建后就会立即执行。
    - 如果调用resolve函数和reject函数时带有参数，那么它们的参数会被传递给回调函数。
    - 对象的状态不受外界影响。
        - Promise 对象代表一个异步操作：
        - 有三种状态：
            - Pending（进行中）
            - Resolved（已完成，又称 Fulfilled）
            - Rejected（已失败）。
            - 只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是 Promise 这个名字的由来，它的英语意思就是「承诺」，表示其他手段无法改变。
    - 一旦状态改变，就不会再变，任何时候都可以得到这个结果。
        - 从 Pending 变为 Resolved 
        - 从 Pending 变为 Rejected。
        - 只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。
        - 这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。
    - 提供异常捕获
5. 缺陷
    - 无法取消 Promise，一旦新建它就会立即执行，无法中途取消
    - 如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部
    - 当处于 Pending 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。
6. 使用
    - 通过new出来的promise对象 
    - 可以使用then方法分别指定Resolved状态和Reject状态的回调函数。
7. 示例
```javaScript
let promise = new Promise(function(resolve, reject) {
  console.log('Promise');
  resolve();
});

promise.then(function() {
  console.log('Resolved.');
});

console.log('Hi!');
```