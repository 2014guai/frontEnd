# 事件机制与线程机制
##概述
* 浏览器没有事件响应就没有行为交互
* 以事件驱动使得功能解耦也是个相当高端大气的技巧了(Node.js)
## js为什么是单线程的?
* 作为浏览器脚本语言, JavaScript的主要用途是与用户互动, 以及操作DOM
  这决定了它只能是单线程, 否则会带来很复杂的同步问题
* 比如, 假定JavaScript同时有两个线程,
  * 一个线程在某个DOM节点上添加内容
  * 另一个线程删除了这个节点, 这时浏览器应该以哪个线程为准？
* 为了避免复杂性
  * 从一诞生, JavaScript就是单线程, 这已经成了这门语言的核心特征, 将来也不会改变
* 为了利用多核CPU的计算能力
  * HTML5提出Web Worker标准, 允许JavaScript脚本创建多个线程, 但是子线程完全受主线程控制, 且不得操作DOM
  * 所以这个新标准并没有改变JavaScript单线程的本质
* JavaScript引擎是单线程的, JS引擎同一时间只执行一条代码
## 任务队列
* 单线程就意味着, 所有任务需要排队, 前一个任务结束, 才会执行后一个任务
* 如果前一个任务耗时很长, 后一个任务就不得不一直等着
* 任务的分类:
  * 在主线程上排队执行的任务, 只有前一个任务执行完毕, 才能执行后一个任务
  * 不进入主线程、而进入"任务队列"(task queue)的任务, 只有"任务队列"通知主线程, 
    某个异步任务可以执行了, 该任务才会进入主线程执行
## 计时器
* 也是一种异步任务
* 计时器的延迟(delay)是无法得到保障的
* 由于所有JavaScript代码是在一个线程里执行的, 所有异步事件(例如, 鼠标点击和计时器)只有拥有执行机会时才会执行
* 浏览器都有一个独立的定时器模块, 定时器的延迟时间就由定时器模块来管理, 
  当某个定时器到了可执行状态, 就会被加入主线程队列
* 使用的时候千万不要太相信预期, 延迟的时间严格来说总是大于x毫秒的, 至于大多少就要看当时JS的执行情况了, 
* 及时清除已经不需要的定时器是个好习惯
* 例如：
  * setTimeout注册的函数fn会交给浏览器的定时器模块来管理, 
    延迟时间到了就将fn加入主进程执行队列, 如果队列前面还有没有执行完的代码, 
    则又需要花一点时间等待才能执行到fn, 所以实际的延迟时间会比设置的长。
    如在fn之前正好有一个超级大循环, 那延迟时间就不是一丁点了
## JavaScript引擎如何实现异步事件
* JavaScript代码执行块会"阻塞"异步事件的执行
* 当一个异步事件发生(例如, 鼠标点击, 计时器被触发, 或者Ajax异步请求)后, 
  这些事件的回调函数将排在执行队列的最后等待执行
## 浏览器内核中的事件循环模型
* 执行栈
* 任务队列, 也称为事件队列/消息队列
## 浏览器内核
* 支持浏览器运行的最核心的程序
* 不同的浏览器可能不太一样
  * Chrome, Safari : webkit
  * firefox : Gecko
  * IE	: Trident
  * 360,搜狗等国内浏览器: Trident + webkit
* 内核由很多模块组成
  * js引擎模块 : 负责js程序的编译与运行
  * 定时器模块 : 负责定时器的管理
  * DOM/CSS模块 : 负责dom/css在内存中的相关处理 
  * 网络请求模块 : 负责服务器请求(常规/Ajax)
  * 事件响应模块 : 负责事件的管理
  * html,css文档解析模块 : 负责页面文本的解析
  * 布局和渲染模块 : 负责页面的布局和效果的绘制
## 总结:
* JavaScript引擎是单线程的, 强制所有的异步事件排队等待执行
* setTimeout 和 setInterval 在执行异步代码的时候有着根本的不同
* 如果一个计时器被阻塞而不能立即执行, 它将延迟执行直到下一次可能执行的时间点才被执行(比期望的时间间隔要长些)
* 如果setInterval回调函数的执行时间将足够长(比指定的时间间隔长), 它们将连续执行并且彼此之间没有时间间隔
* ![](/images/事件机制原理.PNG)



